/**	@file
	@brief クロック管理
*/

#ifndef CLOCK_H_
#define CLOCK_H_

namespace Clock{
	
	// クロックの初期化
	static inline void Init(void){
		// 24MHz発振器を起動
		AVR32_PM.mcctrl   = AVR32_PM_MCCTRL_OSC1EN_MASK | (AVR32_PM_MCCTRL_MCSEL_SLOW << AVR32_PM_MCCTRL_MCSEL);
		AVR32_PM.oscctrl1 = (AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK << AVR32_PM_OSCCTRL1_MODE)
					  | (AVR32_PM_OSCCTRL1_STARTUP_16384_RCOSC << AVR32_PM_OSCCTRL1_STARTUP);
		while(~AVR32_PM.poscsr & AVR32_PM_POSCSR_OSC1RDY_MASK);
		
		// PLL0を起動 (24MHz -> DIV -> 12MHz -> PLL -> 120MHz -> DIV -> 60MHz)
		AVR32_PM.pll[0] = ((10-1) << AVR32_PM_PLL0_PLLMUL) | (2 << AVR32_PM_PLL0_PLLDIV) | (0b111 << AVR32_PM_PLL0_PLLOPT)
				  | (1 << AVR32_PM_PLL0_PLLOSC) | AVR32_PM_PLL0_PLLEN_MASK;
		
		// PLL1を起動 (24MHz -> DIV -> 12MHz -> PLL -> 96MHz -> DIV -> 48MHz)
		AVR32_PM.pll[1] = ((8-1) << AVR32_PM_PLL1_PLLMUL) | (2 << AVR32_PM_PLL1_PLLDIV) | (0b111 << AVR32_PM_PLL1_PLLOPT)
				  | (1 << AVR32_PM_PLL1_PLLOSC) | AVR32_PM_PLL1_PLLEN_MASK;
		
		// PLLロック待ち
		while((AVR32_PM.poscsr & (AVR32_PM_POSCSR_LOCK0_MASK | AVR32_PM_POSCSR_LOCK1_MASK)) != (AVR32_PM_POSCSR_LOCK0_MASK | AVR32_PM_POSCSR_LOCK1_MASK));
		
		// クロック源をPLLに変更
		AVR32_FLASHC.fcr = AVR32_FLASHC_FCR_FWS_MASK;	// 1ウェイト
		AVR32_PM.mcctrl	= AVR32_PM_MCCTRL_OSC1EN_MASK | (AVR32_PM_MCCTRL_MCSEL_PLL0 << AVR32_PM_MCCTRL_MCSEL);	// メインクロックはPLL0
		AVR32_PM.gcctrl[AVR32_PM_GCLK_USBB]	= AVR32_PM_GCCTRL_CEN_MASK
										| AVR32_PM_GCCTRL_PLLSEL_MASK | (1 << AVR32_PM_GCCTRL_OSCSEL);		// USBクロックはPLL1
		
		// 不必要なモジュールへのクロック供給を止める
		//AVR32_PM.hsbmask = 0b11111;
		AVR32_PM.pbamask = 0b01011111111111;	// TC, PWM, USART2, USART1, USART0, TWI, SPI, ADC, PM/RTC/EIC, PDCA, GPIO, INTC
		//AVR32_PM.pbbmask = 0b111;
	}
	
}

#endif
