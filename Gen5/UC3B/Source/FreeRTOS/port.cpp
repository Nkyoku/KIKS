/**	@file
	@brief FreeRTOS port.c for AVR32 UC3
*/
 

/* Standard includes. */
#include <malloc.h>

#include "FreeRTOS.h"
#include "task.h"

#include "../driver/int.h"



/* Constants required to setup the task context. */
#define portINITIAL_SR            ((portSTACK_TYPE) 0x00400000) /* AVR32 : [M2:M0]=001 I1M=0 I0M=0, GM=0 */
#define portINSTRUCTION_SIZE      ((portSTACK_TYPE) 0)

/* Each task maintains its own critical nesting variable. */
#define portNO_CRITICAL_NESTING   ((unsigned long) 0)
volatile unsigned long ulCriticalNesting = 9999UL;

/*-----------------------------------------------------------*/

NAKED vTick();


/*
 * Low-level initialization routine called during startup, before the main
 * function.
 * This version comes in replacement to the default one provided by Newlib.
 * Newlib's _init_startup only calls init_exceptions, but Newlib's exception
 * vectors are not compatible with the SCALL management in the current FreeRTOS
 * port. More low-level initializations are besides added here.
 */
void Tick_Init(void){
	/* 例外を有効にする */
	EnableException();

	// タイマー0初期化
	Int::Register(IRQ_TC0, (void*)vTick, IL_NORMAL);
	
	AVR32_TC.channel[0].cmr	= AVR32_TC_CMR0_WAVE_MASK
						| (AVR32_TC_CMR0_WAVSEL_UP_AUTO << AVR32_TC_CMR0_WAVSEL)
						| (AVR32_TC_CMR0_TCCLKS_TIMER_CLOCK4 << AVR32_TC_CMR0_TCCLKS);
	AVR32_TC.channel[0].rc = (F_CPU / 32) / configTICK_RATE_HZ;
	AVR32_TC.channel[0].ier = AVR32_TC_IER0_CPCS_MASK;
	AVR32_TC.channel[0].ccr = AVR32_TC_CCR0_CLKDIS_MASK;
}
/*-----------------------------------------------------------*/

/*
 * malloc, realloc and free are meant to be called through respectively
 * pvPortMalloc, pvPortRealloc and vPortFree.
 * The latter functions call the former ones from within sections where tasks
 * are suspended, so the latter functions are task-safe. __malloc_lock and
 * __malloc_unlock use the same mechanism to also keep the former functions
 * task-safe as they may be called directly from Newlib's functions.
 * However, all these functions are interrupt-unsafe and SHALL THEREFORE NOT BE
 * CALLED FROM WITHIN AN INTERRUPT, because __malloc_lock and __malloc_unlock do
 * not call portENTER_CRITICAL and portEXIT_CRITICAL in order not to disable
 * interrupts during memory allocation management as this may be a very time-
 * consuming process.
 */

/*
 * Lock routine called by Newlib on malloc / realloc / free entry to guarantee a
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
/*void __malloc_lock(struct _reent *ptr){
	vTaskSuspendAll();
}*/

/*
 * Unlock routine called by Newlib on malloc / realloc / free exit to guarantee
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
/*void __malloc_unlock(struct _reent *ptr){
	xTaskResumeAll();
}*/
/*-----------------------------------------------------------*/

/* Added as there is no such function in FreeRTOS. */
/*void *pvPortRealloc(void *pv, size_t xWantedSize){
	void *pvReturn;

	vTaskSuspendAll();
	pvReturn = realloc(pv, xWantedSize);
	xTaskResumeAll();

	return pvReturn;
}*/
/*-----------------------------------------------------------*/

/* The cooperative scheduler requires a normal IRQ service routine to
simply increment the system tick. */
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
NAKED vTick(){
	/* 現在のコンテキストを保存 */
	portSAVE_CONTEXT_OS_INT();

	/* 割り込みフラグをクリア */
	AVR32_TC.channel[0].sr;
	
	/* チックカウンタをインクリメント */
	portENTER_CRITICAL();
	vTaskIncrementTick();
	portEXIT_CRITICAL();
	
	/* 選ばれた次のコンテキストを復帰 */
	portRESTORE_CONTEXT_OS_INT();
}
/*-----------------------------------------------------------*/

extern "C" NAKED SCALLYield(void){
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
	vTaskSwitchContext();
	portRESTORE_CONTEXT_SCALL();
}
/*-----------------------------------------------------------*/

/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
extern "C" __attribute__((__noinline__)) void vPortEnterCritical(void){
	/* Disable interrupts */
	DisableGlobalInt();

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
}
/*-----------------------------------------------------------*/

extern "C" __attribute__((__noinline__)) void vPortExitCritical(void){
	if(ulCriticalNesting > portNO_CRITICAL_NESTING){
		ulCriticalNesting--;
		if(ulCriticalNesting == portNO_CRITICAL_NESTING){
			/* Enable all interrupt/exception. */
			EnableGlobalInt();
		}
	}
}
/*-----------------------------------------------------------*/

/*
 * Initialise the stack of a task to look exactly as if a call to
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
extern "C" portSTACK_TYPE *pxPortInitialiseStack(portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters){
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = (portSTACK_TYPE) 0x08080808;					/* R8 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0x09090909;					/* R9 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0x0A0A0A0A;					/* R10 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0x0B0B0B0B;					/* R11 */
	*pxTopOfStack-- = (portSTACK_TYPE) pvParameters;					/* R12 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0xDEADBEEF;					/* R14/LR */
	*pxTopOfStack-- = (portSTACK_TYPE) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
	*pxTopOfStack-- = (portSTACK_TYPE) portINITIAL_SR;				/* SR */
	*pxTopOfStack-- = (portSTACK_TYPE) 0xFF0000FF;					/* R0 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0x01010101;					/* R1 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0x02020202;					/* R2 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0x03030303;					/* R3 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0x04040404;					/* R4 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0x05050505;					/* R5 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0x06060606;					/* R6 */
	*pxTopOfStack-- = (portSTACK_TYPE) 0x07070707;					/* R7 */
	*pxTopOfStack = (portSTACK_TYPE) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */

	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

extern "C" portBASE_TYPE xPortStartScheduler(void){
	/* タイマーをスタート */
	AVR32_TC.channel[0].ccr = AVR32_TC_CCR0_SWTRG_MASK | AVR32_TC_CCR0_CLKEN_MASK;

	/* 最初のタスクを開始 */
	portRESTORE_CONTEXT();

	/* Should not get here! */
	return 0;
}
/*-----------------------------------------------------------*/

extern "C" void vPortEndScheduler(void){
	/* タイマー停止  */
	AVR32_TC.channel[0].ccr = AVR32_TC_CCR0_CLKDIS_MASK;
}
/*-----------------------------------------------------------*/
